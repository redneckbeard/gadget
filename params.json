{"name":"Gadget","tagline":"A smallish web framework for Go","body":"Gadget is a smallish web application framework with a soft spot for content\r\nnegotiation. To install Gadget, just use the go tool.\r\n\r\n```\r\n$ go get github.com/redneckbeard/gadget\r\n$ go get github.com/redneckbeard/gadget/templates\r\n```\r\n\r\nThe gdgt package will install a command that will help you generate Gadget\r\nprojects. You don't have to use it, but it does mean mashing fewer buttons. You\r\nneed Go 1.2 to use it.\r\n\r\n```\r\n$ go get github.com/redneckbeard/gadget/gdgt\r\n```\r\n\r\n## Show me how it works!\r\n\r\nThe [README](https://github.com/redneckbeard/gadget/blob/master/README.md) is a\r\nnarrated terminal session of having a first play with Gadget. If that's your\r\nstyle, it may be more helpful than the summaries below.  All the concepts here\r\nare documented more granularly on\r\n[godoc.org](http://godoc.org/github.com/redneckbeard/gadget).\r\n\r\n### Project layout\r\n\r\nFor the most part, you can lay out your Gadget projects however you want. There\r\nis, however, a convention, and you can conform to it most easily by installing\r\nthe `github.com/redneckbeard/gadget/gdgt` subpackage. Using the \"new\" command,\r\nyou can create a ready-to-compile program with the following directory/file\r\nstructure:\r\n\r\n```\r\n.\r\n├── app\r\n│   └── conf.go\r\n├── controllers\r\n│   └── home.go\r\n├── main.go\r\n├── static\r\n│   ├── css\r\n│   ├── img\r\n│   └── js\r\n└── templates\r\n    ├── base.html\r\n    └── home\r\n\t└── index.html\r\n```\r\n\r\nThe app package is where you actually have your Gadget configuration and a\r\npointer to the app object, so you will end up importing that package in files\r\nin the controllers package. main.go also imports app, and actually runs the\r\nthing.\r\n\r\n### Running Gadget\r\n\r\nSince your Gadget application is just a Go package, we can build this with `go\r\ninstall <appname>`, and voilà -- we have a single-file web application / HTTP\r\nserver waiting for as `$GOPATH/bin/<appname>`.\r\n\r\nBecause there are some files that don't go into the build, and the build is\r\njust an executable, Gadget needs an absolute path that it can assume as the\r\nroot that all relative filepaths branch off of. In development, this will often\r\nsimply be the current working directory, and that's the default. However, in\r\nproduction, you might have your binary and your frontend files in completely\r\ndifferent locations. For this reason, we can call the `<appname>` executable\r\nwith a `-root` flag and point it at whatever path we please.\r\n\r\nThe command invoked in an upstart job might then look like:\r\n\r\n```\r\n/usr/local/bin/inspector serve -static=\"/media/\" -root=/home/penny/files/ -debug=false\r\n```\r\n\r\n### Asset files\r\n\r\nGadget assumes that the file root will contain a `static` directory and that\r\nyou want it to serve the contents thereof as files. By default, it will do so\r\nat `/static/`. You can, however, change this to accommodate whatever you have\r\nagainst the word \"static\"... with the `-static` flag.\r\n\r\n## Routing\r\n\r\nRoutes in Gadget are just code. They go in the Configure method of your app in\r\napp/conf.go. \r\n\r\nPeople love HandlerFuncs. So if you want, you can just route stuff to\r\nHandlerFuncs.\r\n\r\n```Go\r\napp.Routes(\r\n\tapp.HandleFunc(\"robots.txt\", func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, \"templates/robots.txt\") }),\r\n)\r\n```\r\n\r\nIf you have lots of routes with a common URL segment, you can factor it out\r\nwith `Prefixed`.\r\n\r\n```Go\r\napp.Routes(\r\n\tapp.Prefixed(\"users\",\r\n\t\tapp.HandleFunc(\"friends\", FriendsIndex),\r\n\t\tapp.HandleFunc(\"frenemies\", FrenemiesIndex),\r\n\t),\r\n)\r\n```\r\n\r\nIn practice, though being able to use HandlerFuncs is very handy, you'll more\r\ncommonly route to RESTful controllers with the `Resource` method.\r\n\r\n```Go\r\napp.Routes(\r\n\tapp.Resource(\"users\",\r\n\t\tapp.Resource(\"friends\"),\r\n\t\tapp.Resource(\"frenemies\"),\r\n\t),\r\n)\r\n```\r\n\r\nIn this example, \"users\", \"friends\", and \"frenemies\" all reference controllers\r\nthat we've registered with the app. To mount at route at the root of the site,\r\nthere's a special `SetIndex` method, which is set up for you automatically if\r\nyou use the gdgt project generator.\r\n\r\n```Go\r\napp.Routes(\r\n\tapp.SetIndex(\"home\"),\r\n\tapp.Resource(\"users\",\r\n\t\tapp.Resource(\"friends\"),\r\n\t\tapp.Resource(\"frenemies\"),\r\n\t),\r\n)\r\n```\r\n\r\n### Controllers\r\n\r\nThe strings that are fed to the `gadget.Resource` calls correspond to the names\r\nof controllers that we defined in our `controllers` package. The files in the\r\ncontrollers package all declare a `gadget.Controller type, embed a pointer to\r\n`gadget.DefaultController` to make it simpler to implement the controller\r\ninterface, and explicitly register that controller with the framework. \r\n\r\n```Go\r\npackage controllers\r\n\r\nimport (\r\n\t\"github.com/redneckbeard/gadget\"\r\n\t\"example/app\"\r\n)\r\n\r\ntype MissionController struct {\r\n\t*gadget.DefaultController\r\n}\r\n\r\nfunc (c *MissionController) Index(r *gadget.Request) (int, interface{}) {\r\n\treturn 200, []&struct{Mission string}{{\"Dr. Claw\"},{\"M.A.D. Cat\"}}\r\n}\r\n\r\nfunc (c *MissionController) Show(r *gadget.Request) (int, interface{}) {\r\n\tmissionId := r.UrlParams[\"mission_id\"]\r\n\treturn 200, \"Mission #\" + missionId + \": this message will self-destruct.\"\r\n}\r\n\r\nfunc (c *MissionController) ChiefQuimby(r *gadget.Request) (int, interface{}) {\r\n\treturn 200, \"You've done it again, Gadget! Don't know how you do it!\"\r\n}\r\n\r\nfunc init() {\r\n\tapp.Register(&MissionController{})\r\n}\r\n```\r\n\r\nController methods have access to a `gadget.Request` object and return simply\r\nan HTTP status code and any value at all for the body (more on why in a bit).\r\nThe controller interface requires `Index`, `Show`, `Create`, `Update`, and\r\n`Destroy` methods. Embedding a pointer to a `DefaultController` means that\r\nthese are all implemented for you. However, _this doesn't provide you with\r\nanything but 404s_. If you want to take action in response to a particular verb,\r\noverride the method.\r\n\r\nThe Gadget router will hit controller methods based on the HTTP verbs that you\r\nwould expect: \r\n\r\n* `GET /missions` routes to `Index`\r\n* `GET /missions/\\d+` routes to `Show`\r\n* `POST /missions` routes `Create`\r\n* `PUT /missions/\\d+` routes to `Update`\r\n* `PATCH /missions/\\d+` routes to `Update`\r\n* `DELETE /missions/\\d+` routes to `Destroy`\r\n\r\nNumeric ids are the default, but if you want something else in your URLs, just\r\noverride `func IdPattern() string` on your controller.\r\n\r\nIn addition, any exported method on the controller will be routed to for all\r\nHTTP verbs. `ChiefQuimby` above would be called for any verb when the requested\r\npath was `/missions/chief-quimby`.\r\n\r\nYou make a Controller available to the router by passing it to `app.Register`.\r\nThis is best done in the init function. Gadget doesn't pretend to speak\r\nperfect English, so it takes the dumbest possible guess at pluralizing your\r\ncontroller's name and just tacks an \"s\" on the end. If inflecting is more\r\ncomplicated, define a `Plural() string` method on your controller.\r\n\r\n#### Action filters\r\n\r\nWhen developing a web application, you frequently have a short-circuit pattern\r\ncommon to a number of controller methods -- \"404 if the user isn't logged in\",\r\n\"Redirect if the user isn't authorized\", etc. To accommodate code reuse, Gadget\r\ncontrollers allow you to define filters on certain actions. Setting one up in\r\nthe example above might look like this:\r\n\r\n\r\n```Go\r\nfunc init() {\r\n\tc := &MissionController{gadget.New()}\r\n\tc.Filter([]string{\"create\", \"update\", \"destroy\"}, UserIsPenny)\r\n\tgadget.Register(c)\r\n}\r\n```\r\n\r\n`UserIsPenny` is just a function with the signature `func(r *requests.Request)\r\n(int, interface{})` just like a controller method. If this function returns a\r\nnon-zero status code, the controller method that was filtered will never be\r\ncalled. If the filter returns a status code of zero, Gadget will move on to the\r\nnext filter for that action until they are exhausted, and then call the\r\ncontroller method.\r\n\r\n### Request and explicit Response objects\r\n\r\n#### Request objects\r\n\r\n`gadget.Request` embeds `http.Request` and provides a few convenience facilities:\r\n\r\n* `Request.UrlParams` is a `map[string]string` of any ids plucked from route URLs\r\n* `Request.Params` is a `map[string]interface{}` of GET/POST parameters, or the deserialized POST body of a request sent with `Content-Type: application/json`\r\n* `Request.User` provides a hook into Gadget's lightweight authentication system\r\n* `Request.Debug()` gives you per-request debug status\r\n\r\n#### Response objects\r\n\r\nIn most cases, returning a status code and a response body are all you need to\r\ndo to respond to a request. When you do need to set cookies or response\r\nheaders, you can wrap the response body value in `gadget.NewResponse` and set\r\ncookies and headers on the value returned.\r\n\r\n```Go\r\nresp := gadget.NewResponse(responseMap)\r\nresp.AddCookie(&http.Cookie{\r\n\tName:    \"lastVisited\",\r\n\tValue:   r.Path,\r\n\tExpires: time.Now().Add(time.Duration(1) * time.Hour),\r\n})\r\nreturn 200, resp\r\n```\r\n\r\n### Brokers\r\n\r\nThe `interface{}` value you that you return from a controller method is by\r\ndefault piped through `fmt.Sprint`. Strings are predictable, as are numbers;\r\nother types look more like debugging output. However, Gadget has a mechanism\r\nfor transforming those values based on `Content-Type` or `Accept` headers. By\r\ndefining Broker functions and assigning them to MIME types, you can make the\r\nsame controller methods speak HTML and JSON.\r\n\r\n```Go\r\napp.Accept(\"application/json\").Via(gadget.JsonBroker)\r\n```\r\n\r\nJSON and XML processors are included with Gadget. Placing the line above in\r\nyour app's `Configure` method will make Gadget serialize the body values\r\nreturned from your controller methods when the appropriate headers are found in\r\nthe request.\r\n\r\nSubpackage `gadget/templates` implements an HTML Broker that wraps the\r\n`html/template` package. `templates.TemplateBroker` attempts to render \r\nthe body value returned from a controller method as the context of an \r\n`html/template.Template`. It requires adherence to a few simple conventions\r\nfor locating templates:\r\n\r\n* All templates are inside a subdirectory of the Gadget application's root as defined by `templates.TemplatePath` (\"templates\" by default).\r\n* A \"templates/base.html\" file exists and can be parsed as a Go template; \r\n* Templates will be loaded from a directory matching the lower-cased plural name of the controller and\r\nthe lower-cased name of the action, plus the extension \".html\". For example,\r\nthe Show method of a FavoriteController would look for a template\r\n\"templates/favorites/show.html.\"\r\n* All error codes can also be served via their own templates. Non-200 statuses\r\nwill result in TemplateBroker looking for a \"templates/403.html\",\r\n\"templates/502.html\", etc.\r\n* Special handling is used for 500s when debug mode is on -- when panics are recovered, the stack trace will be shown in the browser. This does not interfere with 500s that you generate yourself.\r\n\r\n`gadget/templates` additionally provides a registry of helper functions. Any function you want to have available to all templates can be added by passing it to `templates.AddHelper`. The package defines two helpers that are automatically available:\r\n\r\n* `request` gives you access to the current `*gadget.Request`;\r\n* `render` allows you to inject subtemplates (i.e. partials, includes, etc.) into the current template. It takes the name of a template, minus the \".html\" extension, and the context that you want to pass to the subtemplate. It will first look in the \"templates/{{controller}}\" subdirectory for the template specified, and fall back to \"templates\".\r\n\r\n### Users\r\n\r\nGadget doesn't have an authentication framework, but it does have hooks for\r\nplugging one in. It defines: \r\n\r\n* An interface `gadget.User` that has a single method, `Authenticated() bool`\r\n* A default anonymous user (`Authenticated()` always returns false) \r\n* A function type `UserIdentifier` with the signature `func(*Request) User`\r\n\r\nYou define a type that implements `gadget.User` (presumably for which\r\n`Authenticated()` always returns true and then write a `UserIdentifier` that\r\nwill return either your type or `gadget.AnonymousUser`. You can then register\r\nit with the framework by passing it to `gadget.IdentifyUsersWith`. In your\r\ncontroller methods you'll be able to do something like this:\r\n\r\n```Go\r\nif !r.User.Authenticated() {\r\n\treturn 403, \"Unauthorized\"\r\n}\r\nuser := r.User.(*models.User)\r\n```\r\n\r\n### Debugging and logging\r\n\r\nThe \"serve\" command registered by package `github.com/redneckbeard/gadget/env`\r\ndefines a debug flag. You can access that flag as `env.Debug`. You write a lot\r\nof code inside controller methods, so as a convenience, you can check the value\r\nof `env.Debug` by calling `Request.Debug`.\r\n\r\nIf you need per-request debug state -- for example, seeing debugging variables\r\nin the browser for an administrative user -- you can hook into\r\n`Request.Debug()` by setting `gadget.SetDebugWith` to a function you define\r\nwith the signature `func(*Request) bool`.\r\n\r\nThe `env` subpackage also provides some rudimentary logging facilities. `env.Log(interface{}...)` will write to stdout by default, but a file location can be specified with the `-log` flag when running the `serve` command. Basic data about the request/response cycle is automatically logged, and the output looks like this:\r\n\r\n`[04 Dec 13 20:44 EST] \"GET / HTTP/1.1\" 200 2825`\r\n\r\n(That's time, obvious HTTP stuff, response status code, bytes written.) Similarly to `gadget.SetDebugWith`, you can override the request logging behavior by assigning a `func(r *Request, status, contentLength int) string` to `gadget.RequestLogger`.\r\n\r\nGadget will recover from panics; in debug mode, in returns the stack trace to the client. If debug mode is off, however, it will simply return an empty 500 and log the stack trace via `env.Log`.\r\n\r\n### Custom command line tools\r\n\r\nGadget uses [Quimby](http://github.com/redneckbeard/quimby) to support multiple\r\ncommands from the same binary. You can just as easily register your own. Follow\r\nthe example in the Quimby README.\r\n\r\n## Sites using Gadget\r\n\r\nGadget is used by [farmr.org](http://farmr.org), New England's 4th most popular\r\nwebsite about database-driven urban farm management.","google":"UA-43853030-2","note":"Don't delete this file! It's used internally to help with page regeneration."}